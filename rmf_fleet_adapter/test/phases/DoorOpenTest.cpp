/*
 * Copyright (C) 2020 Open Source Robotics Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
*/

#include "TransportFixture.hpp"

#include <phases/DoorOpen.hpp>
#include <rmf_fleet_adapter/StandardNames.hpp>
#include <rmf_utils/catch.hpp>

namespace rmf_fleet_adapter {
namespace phases {
namespace test {

using rmf_door_msgs::msg::DoorRequest;
using rmf_door_msgs::msg::DoorMode;
using rmf_door_msgs::msg::DoorState;
using rmf_door_msgs::msg::SupervisorHeartbeat;
using rmf_door_msgs::msg::DoorSessions;
using rmf_door_msgs::msg::Session;

SCENARIO_METHOD(TransportFixture, "door open phase")
{
  std::string door_name = "test_door";
  auto door_state_obs = transport->create_observable<DoorState>(DoorStateTopicName, 10);
  auto heartbeat_obs = transport->create_observable<SupervisorHeartbeat>(DoorSupervisorHeartbeatTopicName, 10);
  auto pending_phase = std::make_shared<DoorOpen::PendingPhase>(
    door_name,
    transport,
    door_state_obs,
    heartbeat_obs
  );
  auto active_phase = pending_phase->begin();

  std::mutex m;
  std::condition_variable received_requests_cv;
  std::list<DoorRequest::UniquePtr> received_requests;
  auto rcl_subscription = transport->create_subscription<DoorRequest>(
    AdapterDoorRequestTopicName,
    10,
    [&](DoorRequest::UniquePtr door_request)
    {
      std::unique_lock<std::mutex> lk(m);
      received_requests.emplace_back(std::move(door_request));
      received_requests_cv.notify_all();
    });

  GIVEN("a door open phase")
  {
    WHEN("it is cancelled before its started")
    {
      active_phase->cancel();

      THEN("it should not send door open requests")
      {
        bool received_open = false;
        rxcpp::composite_subscription rx_sub;
        auto subscription = transport->create_subscription<DoorRequest>(
          AdapterDoorRequestTopicName,
          10,
          [&](DoorRequest::UniquePtr door_request)
          {
            if (door_request->requested_mode.value == DoorMode::MODE_OPEN)
              received_open = true;
            else if (door_request->requested_mode.value == DoorMode::MODE_CLOSED)
              rx_sub.unsubscribe();
          });
        auto obs = active_phase->observe();
        obs.as_blocking().subscribe(rx_sub);
        REQUIRE(!received_open);
      }
    }

    WHEN("it is started")
    {
      std::condition_variable status_updates_cv;
      std::list<Task::StatusMsg> status_updates;
      auto sub = active_phase->observe().subscribe(
        [&](const auto& status)
        {
          std::unique_lock<std::mutex> lk(m);
          status_updates.emplace_back(status);
          status_updates_cv.notify_all();
        });

      THEN("it should send door open request")
      {
        std::unique_lock<std::mutex> lk(m);
        if (received_requests.empty())
          received_requests_cv.wait(lk, [&]() { return !received_requests.empty(); });
        REQUIRE(received_requests.size() == 1);
        REQUIRE(received_requests.front()->requested_mode.value == DoorMode::MODE_OPEN);
      }

      THEN("it should continuously send door open requests")
      {
        std::unique_lock<std::mutex> lk(m);
        received_requests_cv.wait(lk, [&]() { return received_requests.size() >= 3; });
      }

      /**
       * The phase should go through the following life cycle
       *   1. heartbeat does not have session
       *   2. send door open request
       *   3. heartbeat has session, door state transition to moving or open, these 2 events can
       *     happen simultaneously
       *   4. heartbeat no longer has session, door state should be opened at this point
       *
       * When the observable is subscribed it should send a door request, moving to step 2.
       *
       * The 1st callback happens when it receives a door state and heartbeat message, this is due
       * to how rxcpp `combine_latest` work, it only starts emitting when all the observables have
       * emitted at least one item. At this point, it should receive door state = open and heartbeat
       * containing the session. This moves it to step 3.
       *
       * 2nd callback happens when the 2nd heartbeat message is received, at this point the door state
       * is still opened, and the heartbeat no longer has the session, the phase is now completed.
       */
      THEN("it should complete only after door supervisor releases session")
      {
        std::condition_variable published_heartbeat_cv;
        std::atomic<bool> published_heartbeat(false);
        auto door_state_pub = transport->create_publisher<DoorState>(DoorStateTopicName, 10);
        auto heartbeat_pub = transport->create_publisher<SupervisorHeartbeat>(DoorSupervisorHeartbeatTopicName, 10);
        auto rcl_subscription2 = transport->create_subscription<DoorRequest>(
          AdapterDoorRequestTopicName,
          10,
          [&](DoorRequest::UniquePtr door_request)
          {
            DoorState door_state;
            door_state.door_name = door_name;
            door_state.door_time = transport->now();
            door_state.current_mode.value = door_request->requested_mode.value;
            door_state_pub->publish(door_state);

            Session session;
            session.requester_id = door_request->requester_id;
            session.request_time = door_request->request_time;
            DoorSessions door_sessions;
            door_sessions.door_name = door_request->door_name;
            door_sessions.sessions.emplace_back(std::move(session));
            SupervisorHeartbeat heartbeat;
            heartbeat.all_sessions.emplace_back(std::move(door_sessions));
            heartbeat_pub->publish(heartbeat);
            published_heartbeat = true;
            published_heartbeat_cv.notify_all();
          });

        {
          std::unique_lock<std::mutex> lk(m);
          published_heartbeat_cv.wait(lk, [&]() { return published_heartbeat.load(); });
        }

        // phase should not complete yet as supervisor haven't release the session
        {
          std::unique_lock<std::mutex> lk(m);
          bool completed = status_updates_cv.wait_for(lk, std::chrono::seconds(1), [&]()
          {
            for (const auto& status : status_updates)
            {
              if (status.state == Task::StatusMsg::STATE_COMPLETED)
                return true;
            }
            status_updates.clear();
            return false;
          });
          REQUIRE(!completed);
        }

        // supervisor released session
        heartbeat_pub->publish(SupervisorHeartbeat());

        // phase should now complete
        {
          std::unique_lock<std::mutex> lk(m);
          bool completed = status_updates_cv.wait_for(lk, std::chrono::seconds(1), [&]()
          {
            for (const auto& status : status_updates)
            {
              if (status.state == Task::StatusMsg::STATE_COMPLETED)
                return true;
            }
            status_updates.clear();
            return false;
          });
          REQUIRE(completed);
        }
      }

      sub.unsubscribe();
    }

    WHEN("it is started and then cancelled")
    {
      auto sub = active_phase->observe().subscribe();
      {
        std::unique_lock<std::mutex> lk(m);
        if (received_requests.empty())
          received_requests_cv.wait(lk, [&]() { return !received_requests.empty(); });
      }
      active_phase->cancel();

      THEN("it should send door close request")
      {
        std::unique_lock<std::mutex> lk(m);
        while (received_requests.back()->requested_mode.value != DoorMode::MODE_CLOSED)
        {
          received_requests_cv.wait(lk);
        }
      }

      sub.unsubscribe();
    }
  }
}

} // namespace test
} // namespace phases
} // namespace rmf_fleet_adapter